var bb = require('bot-brother');
var config = require('config');
var chrono = require('chrono-node');
var timezoneDetector = require('timezone-detector');
var redisNotifier = require('redis-notifier');
var texts = require('texts');
var moment = require('moment');
var mtz = require('mtz');
var _s = require('underscore.string');

var bot = module.exports = bb({
  key: config.bot.key,
  redis: config.redis
})
.texts(texts.ru, {locale: 'ru'})
.texts(texts.en, {locale: 'en'})
.texts(texts.default)
// define keyboard
.keyboard([
  [{'button.add': {go: 'add'}}],
  [{'button.list': {
    go: 'list',
    canShow: function (ctx) {
      return ctx.notifications.length;
    }
  }}],
  [{'button.settings': {go: 'settings'}}]
])
.keyboard('backButton', [
  [{
    'button.back': {
      handler: function (ctx) {
        return ctx.goBack();
      },
      canShow: function (ctx) {
        return !ctx.hideBackButton;
      }
    }
  }]
])
.keyboard('cancelButton', [
  [{
    'button.cancel': {go: 'start'}
  }]
])
.use('before', function (ctx) {
  ctx.data.user = ctx.meta.user;
  ctx.notifications = ctx.session.notifications = ctx.session.notifications || [];
  ctx.session.notificationsCounter = ctx.session.notificationsCounter || 0;

  ctx.settings = ctx.settings || {};
  ctx.setLocale(ctx.session.locale || config.defaults.locale);
  ctx.timezone = ctx.session.timezone || config.defaults.timezone;

  if (!ctx.session.locale && ctx.command.name !== 'settings_locale') {
    return ctx.go('settings_locale');
  }
  if (!ctx.session.timezone && ctx.command.name !== 'settings_timezone') {
    return ctx.go('settings_timezone');
  }
});


bot.command('start')
.invoke(function (ctx) {
  return ctx.sendMessage('main.start');
});


bot.command('settings')
.invoke(function (ctx) {
  ctx.data.settings = {
    locale: ctx.getLocale(),
    timezone: ctx.timezone
  };
  return ctx.sendMessage('settings.main');
})
.keyboard([
  [{'button.locale': {go: 'locale'}}],
  [{'button.timezone': {go: 'timezone'}}],
  'backButton'
]);


// Setting timezone
// compliantKeyboard to get cityname and latlon answer
bot.command('settings_timezone', {compliantKeyboard: true})
.invoke(function (ctx) {
  return ctx.sendMessage('settings.timezone');
})
.answer(function (ctx) {
  return timezoneDetector(ctx.message.location || ctx.answer).then(function (timezone) {
    if (!timezone) {
      throw new Error('no timezone');
    }
    ctx.timezone = ctx.session.timezone = timezone;
    return ctx.sendMessage('answer.success').then(function () {
      return ctx.goBack();
    });
  }).catch(function (err) {
    console.error(err, err.stack);
    return ctx.repeat();
  });
})
.keyboard([
  [{'buttons.ru': 'ru'}]
  [{'buttons.en': 'en'}]
  'backButton'
]);


// Setting locale
bot.command('settings_locale')
.invoke(function (ctx) {
  return ctx.sendMessage('settings.locale');
})
.answer(function (ctx) {
  ctx.session.locale = ctx.answer;
  ctx.setLocale(ctx.answer);
  return ctx.sendMessage('aswer.success').then(function () {
    return ctx.goBack();
  });
})
.keyboard([
  [{'buttons.ru': 'ru'}]
  [{'buttons.en': 'en'}]
  'backButton'
]);


bot.command('add', {compliantKeyboard: true})
.invoke(function () {
  return ctx.sendMessage('main.add');
})
.answer(function (ctx) {
  if (!ctx.answer) {
    return;
  }
  var notifyOptions = getNotifyOptions(ctx.answer, ctx.timezone);
  if (notifyOptions) {
    addNotification(ctx.meta.chat.id, ctx.session, notifyOptions.text, notifyOptions.unixTimestamp, notifyOptions.expireOffset);
    return ctx.sendMessage('answer.success');
  } else {
    return ctx.go('time', {args: [ctx.answer]});
  }
})
.keyboard([
  'cancelButton'
]);


bot.command('time')
.invoke(function (ctx) {
  var text = ctx.command.args[0];
  if (!text) {
    return;
  }
  return ctx.sendMessage('main.time');
})
.answer(function (ctx) {
  var text = ctx.command.args[0];
  var notifyOptions = getNotifyOptions(ctx.answer, ctx.timezone);
  if (!notifyOptions) {
    return ctx.repeat();
  }
  addNotification(ctx.meta.chat.id, ctx.session, text, notifyOptions.unixTimestamp, notifyOptions.expireOffset);
  return ctx.sendMessage('answer.success');
})
.keyboard([
  'cancelButton'
]);


bot.command('list', {compliantKeyboard: true})
.invoke(function (ctx) {
  if (!ctx.notifications.length) {
    return;
  }
  var message = '';
  ctx.notifications.forEach(function (notification, i) {
    message += (i + 1) + '. ' +
      _s.truncate(notification.text, 18) +
      ' (' + mtz(notification.ts * 1e3).tz(ctx.timezone).format('DD.MM.YYYY HH:mm:ss') +')' +
      '\n';
  });
  ctx.sendMessage('list').then(function () {
    ctx.sendMessage('main.remove');
  });
})
.answer(function (ctx) {
  if (isNaN(ctx.answer)) {
    return;
  }
  ctx.session.notifications.splice(Number(ctx.answer) - 1, 1);
  return ctx.sendMessage('answer.success').then(function () {
    ctx.repeat();
  });
});


redisNotifier.on('expired', function (chatId, taskId) {
  bot.withContext(chatId, function (ctx) {
    var notification = getNotification(ctx.session, taskId);
    if (notification) {
      removeNotification(session, taskId);
      return ctx.sendMessage(notification.text);
    }
  });
})


function addNotification (chatId, session, text, unixTimestamp, expireOffset) {
  var id = ++session.notificationsCounter;
  var notification = {
    id: id,
    text: text,
    ts: unixTimestamp
  };
  session.notifications.push(notification);
  redisNotifier.push(chatId, id, expireOffset);
}

function getNotification (session, id) {
  _.find(session.notifications, {id: id});
}

function removeNotification (session) {
  _.remove(session.notifications, {id: id});
}

function getNotifyOptions (text, timezone) {
  var res;
  var resMoment;
  var options = {
    expireOffset: null, // expire offset in seconds
    unixTimestamp: null,
    text: text
  };
  try {
    res = chrono.parse(text);
  } catch (e) {
    console.error(e, e.stack);
    return null;
  }

  if (!res || !res.length) {
    return null;
  }

  res = res[res.length - 1];
  resDate = chrono.parseDate(res.text);

  if (res.tags.RUDeadlineFormatParser || res.tags.ENDeadlineFormatParser) {
    resMoment = moment(resDate);
    options.unixTimestamp = resMoment.unix();
    options.expireOffset = resMoment.diff(new Date, 'seconds');
  } else {
    var offset = -resDate.getTimezoneOffset();
    var realOffset = mtz().tz(timezone).utcOffset();
    resMoment = moment(Number(resDate) + realOffset - offset);
    options.unixTimestamp = resMoment.unix();
    options.expireOffset = resMoment.diff(new Date, 'seconds');
  }

  if (text.length - (res.index + res.text.length) <= 1) {
    options.text = _s(options.text).trim().splice(res.text.index, res.text.length).value();
  }

  if (options.expireOffset < 0) {
    return null;
  }

  return options;
}
